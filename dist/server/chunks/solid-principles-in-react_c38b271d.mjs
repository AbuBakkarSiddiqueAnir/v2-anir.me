const id = "solid-principles-in-react.mdoc";
						const collection = "articles";
						const slug = "solid-principles-in-react";
						const body = "> #### I'm pretty sure, as a software developer, you have a sound knowledge of solid principles and you always use them in your code :) Just jokinggg!\n\nOhh, It's about react! Gosh, we don't need those principles in react! do we?\n\nI myself have been working with react for more than two and half years. And also it happens that, i knew about  solid principles for more than 2 years. but it just happened like some months ago,from i have been tryyying.. consciously to use them in my react code. And believe ,e, it had changed my code structure.\n\nNo more nonsense talk, just dive into main topic.😠.....oka oka..\n\nGonna be a boring article, let me get a coffee for you please...\n\n![](/content/images/solid-principles-in-react/coffe-gif.gif)\n\n### \n\n> ### 1. Single Responsibility Principle (SRP)\n\n##### A class should serve a single, clearly defined purpose, reducing the need for frequent changes.\n\nWe can implement the srp into our react code, by making sure that each component in our application has a specific, well-defined work to do. Likely, a component can be responsible for displaying a static part of a page, handling a user input or doing some fetch calls. By limiting and controlling the responsibility, we can improve the code quality , clarity and maintainability of our code-base.\n\n- Better not mix different/'different kind of' jobs in one component\n- Using composition will make sure reusable components will be able to build complex UI's.\n- Need to handle props and state wisely\n\nWe need to make our components small and do one single thing.\n\n```javascript\nimport React, { useEffect, useState } from \"react\";\nimport axios from \"axios\";\n\nconst ListOfEmployees = () => {\n const [employees, setEmployees] = useState([]);\n const [isLoading, setIsLoading] = useState(true);\n\n useEffect(() => {\n   axios.get(\"https://.../employees/\").then((res) => {\n       setEmployees(res.data)\n   }).catch(e => {\n       console.log(e.message);\n   }).finally(() => {\n       setIsLoading(false);\n   })\n }, [])\n\n if (isLoading){\n   return <p>Loading...</p>\n }\n\n return (\n   <section>\n       {employees.map(employee => {\n           return (\n               <article>\n                    <img src={{uri:employee.img}} />\n                    <p>{item.name}</p>\n                    <p>{item.description}</p>\n               </article>\n           )\n       })}\n   </section>\n );\n};\n\nexport default ListItems;\n```\n\n###### At first this component code may look like decent enough. But if we dive into the responsibility it has taken, we can easily look into the issues within it.\n\n1. Managing the state\n1. Making fetch calls to remote server\n1. Conditionally rendering the view\n\nSo, in general, its clear that **ListOfEmployees** is not align with the SRP. In that case, we can try to refactor/rewrite this component.\n\nFirst we can pull out the code block that is responsible for the state management and fetch calls by creating a hook.\n\n```javascript\nimport React, { useEffect, useState } from \"react\";\nimport axios from \"axios\";\n\nconst useFetchEmployees = () => {\n const [employees, setEmployees] = useState([]);\n const [isLoading, setIsLoading] = useState(true);\n\nuseEffect(() => {\n   axios.get(\"https://.../employees/\").then((res) => {\n       setEmployees(res.data)\n   }).catch(e => {\n       console.log(e.message);\n   }).finally(() => {\n       setIsLoading(false);\n   })\n }, [])\n\n   return { listItems, isLoading };\n}\n```\n\nNow, the **ListOfEmployees looks like,**\n\n```javascript\nimport { useFetchEmployees } from \"hooks/useFetchEmployees\";\n\nconst ListItems = () => {\n const { employees, isLoading } = useFetchEmployees();\n\n\nif (isLoading){\n   return <Text>Loading...</Text>\n }\n\n return (\n   <section>\n       {employees.map(employee => {\n           return (\n               <article>\n                    <img src={{uri:employee.img}} />\n                    <p>{item.name}</p>\n                    <p>{item.description}</p>\n               </article>\n           )\n       })}\n   </section>\n );\n};\n\n\nexport default ListItems;\n```\n\nOhh, Now, this code looks more manageable,\n\nOpps, **useFetchEmployees doing two things at once**\n\n- Managing the state\n- Doing fetch calls\n\nSo, SRP hasn't been maintained, we need do something about it.\n\nWe can outsource the api call from **useFetchEmployees,**\n\n```javascript\nimport axios from \"axios\";\n\nconst fetchEmployees = () => {\n return axios\n   .get(\"https://.../employees/\")\n   .catch((e) => {\n     console(e.message);\n   })\n   .then((res) => res.data);\n};\n\n```\n\nAnd Now **useFetchEmployees** looks like,\n\n```javascript\nimport { useEffect, useState } from \"react\";\nimport { fetchEmployees } from \"./api\";\n\nconst useFetchEmployees = () => {\n const [employess, setEmployess] = useState([]);\n const [isLoading, setIsLoading] = useState(true);\n\n useEffect(() => {\n   fetchEmployees()\n     .then((listItems) => setEmployess(listItems))\n     .finally(() => setIsLoading(false));\n }, []);\n\n\n return { listItems, isLoading };\n};\n```\n\nOWW, everything got put into place. But need to remember, there are times, when SRP may be responsible for complexity than it solves. It's on our shoulder to make our code manageable and understandable.\n\n> ### **2. Open/Closed Principle (OCP)**\n\n##### *\"Entitities (classes, modules, functions, etc.) should be open for extension but clossed for modification\"*\n\n- Open for extension: it means we can add new behaviors, functionalities, and features to a component without having to change it's previous behaviours.\n- Closed for modifications: After we have created and implemented a component, we should avoid directly manipulating its source code.\n\nLets take a look on this following example, that may clear it up,\n\n```javascript\nimport React from 'react';\n\ninterface IListItem {\n  title: string;\n  image: string;\n  isAuth: boolean;\n  onClickMember: () => void;\n  onClickGuest: () => void;\n}\n\nconst ListItem: React.FC<ILıstItem> = ({ title, image, isAuth, onClickMember, onClickGuest }: IListItem) => {\n  const handleMember = () => {\n    // Some logic\n    onClickMember();\n  };\n\n  const handleGuest = () => {\n    // Some logic\n    onClickGuest();\n  };\n  return (\n    <article>\n      <img source={{uri:image}} />\n      <p>{title}</p>\n      {\n      isAuth ? \n           <button onClick={handleMember}>Add to cart +</button> :\n               <button onClick={handleGuest}>Show Modal</button>\n       }\n    </article>\n  );\n};\n\n```\n\nAs we can see, the code  does not fit with the OCP. It violets by rendering different features depending on Authentication status.\n\nWe need to refactor this component,\n\n```javascript\ninterface IButtonHandler {\n  handle(): void;\n}\n\nexport const GuestButtonHandler: React.FC<{ onClickGuest?: () => void }> = ({ onClickGuest }) => {\n  const handle = () => {\n    // Some logic for guests\n    onClickGuest();\n  };\n\n  return <Button onClick={handle}>Show Modal</Button>;\n};\n\nexport const MemberButtonHandler: React.FC<{ onClickMember?: () => void }> = ({ onClickMember }) => {\n  const handle = () => {\n    // Some logic for members\n    onClickMember();\n  };\n\n  return <button onClick={handle}>Add to cart +</button>;\n};\n```\n\n```javascript\nimport React from 'react';\n\ninterface IListItem {\n  title: string;\n  image: string;\n}\n\nexport const ListItem: React.FC<IListItem> = ({ title, image, children}) => {\n\n  return (\n    <article>\n      <img source={{ uri: image }} />\n      <p>{title}</p>\n      {children}\n    </article>\n  );\n};\n\nexport default ListItem;\n```\n\nand finally, we got rid of the unnecessary codes and create new props which is&nbsp;`children`&nbsp;so the other component can extend this component by passing it as a child. Now our ListItem component will be&nbsp;**Open**&nbsp;for extension and&nbsp;**Closed**&nbsp;for modification.\n\n> ### **3. Liskov Substitution Principle (LSP)**\n\n##### *\"The behavior of the superclass should be preserved when substituted with an object of its subclass\"*\n\nBy adhering with LSP, we can ensure that your code remains modular, flexible, and maintainable, as it allows for polymorphism and promotes the reuse of code.\n\n```javascript\nconst SuccessButton = () => {\n  return (\n      <p>Success</p>\n  );\n};\n```\n\nSo we want to create a&nbsp;**`SuccessButton`**&nbsp;component but a button functionality couldn't be replaced by a&nbsp;'p'&nbsp;so this violates the principle. What we should do instead is just return a button like this:\n\n```javascript\nconst SuccessButton = () => {\n  return (\n    <button style={styles.button} onPress={onPress}>\n      <p>Success</p>\n    </button>\n  );\n};\n```\n\nThis is better but it is not enough. We also should inherit all the features of the button itself:\n\n```javascript\nconst SuccessButton = () => {\n  return (\n    <button style={styles.button} onPress={onPress}  {…props}>\n      <p>Success</p>\n    </button>\n  );\n};\n```\n\nNow we inherited all of the attributes of the button and we pass the attributes to the new button. Also, any instance of SuccessButton can still be used in place of an instance of Button without changing the program’s behavior and following the&nbsp;**LSP.**\n\n---\n\n> ### **4. Interface Segregation Principle (ISP)**\n\n##### ''N*o code should be forced to depend on methods it does not use”*[*\\**](https://en.wikipedia.org/wiki/Interface_segregation_principle#cite_note-ASD-1)*.&nbsp;For React applications, we will rephrase it as&nbsp;“components should not depend on props they don’t use.\"*\n\nNo Talk, better, Look into an example snippet\n\n```javascript\nconst ListItem = ({item}) => {\n\n  return (\n    <article>\n      <img source={{uri:item.image}} />\n      <p>{item.title}</p>\n      <p>{item.description}</p>\n    </article>\n  );\n};\n```\n\nWe have a&nbsp;**`ListItem`**&nbsp;component which only needs a few data from the item prop, but, we end up giving it more than the component actually needs because the`item`&nbsp;props itself might contain data that the component doesn’t need\n\nTo solve this problem we may limit the props to only what the component needs,\n\n```javascript\nconst ListItem = ({image, title, description}) => {\n\n  return (\n    <View>\n      <img source={{uri:image}} />\n      <p>{title}</p>\n      <p>{description}</p>\n    </View>\n  );\n};\n```\n\n&nbsp;And now our component is compatible with the&nbsp;**ISP**&nbsp;principle.\n\n> ### **5. Dependency Inversion Principle (DIP)**\n\n##### *\"High-level modules should not import anything from low-level modules. Both should depend on abstractions (e.g., interfaces). And abstractions should not depend on details. Details (concrete implementations) should depend on abstractions\"*\n\nIn the context of React, this principle ensures high-level components should not directly depend on low-level components, but both should depend on a common abstraction. In this case, “component” refers to any part of the application, whether it’s a React component, a function, a module, a class-based component, or a third-party library. Lets see with examples:\n\n```javascript\nconst CreateListItemForm = () => {\n  const handleCreateListItemForm = async (e) => {\n    try {\n      const formData = new FormData(e.currentTarget);\n      await axios.post(\"https://myapi.com/listItems\", formData);\n    } catch (err) {\n      console.error(err.message);\n    }\n  };\n\n  return (\n    <form onSubmit={handleCreateListItemForm}>\n      <input name=\"title\" />\n      <input name=\"description\" />\n      <input name=\"image\" />\n    </form>\n  );\n};\n```\n\nThe component above shows a form for handling creating a list item by rendering a form and sending the submitted data to an API.\n\nConsider this scenario. There’s another form for editing a list item with the same UI but differing only in terms of logic(in our example it is an API endpoint). Our form would be unreusable since we need another endpoint to submit our edit form. Therefore, we need to create a component that isn’t dependent on a specific low-level module.\n\n```javascript\nconst ListItemForm = ({ onSubmit }) => {\n  return (\n    <form onSubmit={onSubmit}>\n      <input name=\"title\" />\n      <input name=\"description\" />\n      <input name=\"image\" />\n    </form>\n  );\n};\n```\n\nWe have removed the dependency from the form and now we can give it the necessary logic through props.\n\n```javascript\nconst CreateListItemForm = () => {\n  const handleCreateListItem = async (e) => {\n    try {\n      const formData = new FormData(e.currentTarget);\n      await axios.post(\"https://myapi.com/listItems\", formData);\n    } catch (err) {\n      console.error(err.message);\n    }\n  };\n  return <ListItemForm onSubmit={handleCreateListItem} />;\n};\n```\n\n```javascript\nconst EditListItemForm = () => {\n  const handleEditListItem = async (e) => {\n    try {\n      // Editing logic\n    } catch (err) {\n      console.error(err.message);\n    }\n  };\n  return <ListItemForm onSubmit={handleEditListItem} />;\n};\n```\n\nBy applying the DIP, we can test each component separately without being concerned about affecting other connected parts.\n\n##### I tried to explain the **** ***S.O.L.I.D in the context of react code. Hope it helped you :)***😃😃\n";
						const data = {title:"Solid Principles in React",short:"I'm pretty sure, as a software developer, you have a sound knowledge of solid principles and you always use them in your code :) Just jokinggg!",date:"2024-02-08",heroImage:"/images/hero/solid-principles-in-react/heroImage.webp",tags:["React","solid principles"]};
						const _internal = {
							type: 'content',
							filePath: "/home/leopard/Desktop/works/v2.anir.me/src/content/articles/solid-principles-in-react.mdoc",
							rawData: "\ntitle: Solid Principles in React\nshort: >-\n  I'm pretty sure, as a software developer, you have a sound knowledge of solid\n  principles and you always use them in your code :) Just jokinggg!\ndate: '2024-02-08'\nheroImage: /images/hero/solid-principles-in-react/heroImage.webp\ntags:\n  - React\n  - solid principles",
						};

export { _internal, body, collection, data, id, slug };
